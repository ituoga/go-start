// Code generated by "sqlc-gen-zombiezen". DO NOT EDIT.

package zz

import (
	"fmt"

	"zombiezen.com/go/sqlite"

	"time"

	"github.com/delaneyj/toolbelt"
)

type InvoiceAllRes struct {
	Id               int64     `json:"id"`
	Uuid             string    `json:"uuid"`
	DocumentDate     time.Time `json:"document_date"`
	DueDate          time.Time `json:"due_date"`
	Currency         string    `json:"currency"`
	Rate             float64   `json:"rate"`
	SerialName       string    `json:"serial_name"`
	SerialNo         int64     `json:"serial_no"`
	RecipientName    string    `json:"recipient_name"`
	RecipientCode    string    `json:"recipient_code"`
	RecipientTaxid   string    `json:"recipient_taxid"`
	RecipientEmail   string    `json:"recipient_email"`
	RecipientPhone   string    `json:"recipient_phone"`
	RecipientAddr    string    `json:"recipient_addr"`
	RecipientCountry string    `json:"recipient_country"`
	WrittenBy        string    `json:"written_by"`
	TakenBy          string    `json:"taken_by"`
	AmountWithVat    time.Time `json:"amount_with_vat"`
	AmountVat        time.Time `json:"amount_vat"`
	AmountTotal      float64   `json:"amount_total"`
	CreatedAt        time.Time `json:"created_at"`
	UpdatedAt        time.Time `json:"updated_at"`
}

type InvoiceAllStmt struct {
	stmt *sqlite.Stmt
}

func InvoiceAll(tx *sqlite.Conn) *InvoiceAllStmt {
	// Prepare the statement into connection cache
	stmt := tx.Prep(`
select id, uuid, document_date, due_date, currency, rate, serial_name, serial_no, recipient_name, recipient_code, recipient_taxid, recipient_email, recipient_phone, recipient_addr, recipient_country, written_by, taken_by, amount_with_vat, amount_vat, amount_total, created_at, updated_at from invoices order by id desc
    `)
	ps := &InvoiceAllStmt{stmt: stmt}
	return ps
}

func (ps *InvoiceAllStmt) Run() (
	res []InvoiceAllRes,
	err error,
) {
	defer ps.stmt.Reset()

	// Execute the query
	for {
		if hasRow, err := ps.stmt.Step(); err != nil {
			return res, fmt.Errorf("failed to execute {{.Name.Lower}} SQL: %w", err)
		} else if !hasRow {
			break
		}

		row := InvoiceAllRes{}
		row.Id = ps.stmt.ColumnInt64(0)
		row.Uuid = ps.stmt.ColumnText(1)
		row.DocumentDate = toolbelt.JulianDayToTime(ps.stmt.ColumnFloat(2))
		row.DueDate = toolbelt.JulianDayToTime(ps.stmt.ColumnFloat(3))
		row.Currency = ps.stmt.ColumnText(4)
		row.Rate = ps.stmt.ColumnFloat(5)
		row.SerialName = ps.stmt.ColumnText(6)
		row.SerialNo = ps.stmt.ColumnInt64(7)
		row.RecipientName = ps.stmt.ColumnText(8)
		row.RecipientCode = ps.stmt.ColumnText(9)
		row.RecipientTaxid = ps.stmt.ColumnText(10)
		row.RecipientEmail = ps.stmt.ColumnText(11)
		row.RecipientPhone = ps.stmt.ColumnText(12)
		row.RecipientAddr = ps.stmt.ColumnText(13)
		row.RecipientCountry = ps.stmt.ColumnText(14)
		row.WrittenBy = ps.stmt.ColumnText(15)
		row.TakenBy = ps.stmt.ColumnText(16)
		row.AmountWithVat = toolbelt.JulianDayToTime(ps.stmt.ColumnFloat(17))
		row.AmountVat = toolbelt.JulianDayToTime(ps.stmt.ColumnFloat(18))
		row.AmountTotal = ps.stmt.ColumnFloat(19)
		row.CreatedAt = toolbelt.JulianDayToTime(ps.stmt.ColumnFloat(20))
		row.UpdatedAt = toolbelt.JulianDayToTime(ps.stmt.ColumnFloat(21))
		res = append(res, row)
	}

	return res, nil
}

func OnceInvoiceAll(
	tx *sqlite.Conn,
) (
	res []InvoiceAllRes,
	err error,
) {
	ps := InvoiceAll(tx)

	return ps.Run()
}
