// Code generated by "sqlc-gen-zombiezen". DO NOT EDIT.

package zz

import (
	"fmt"
	"time"

	"github.com/delaneyj/toolbelt"
	"zombiezen.com/go/sqlite"
)

type InvoiceRowModel struct {
	Id        int64     `json:"id"`
	InvoiceId int64     `json:"invoice_id"`
	Number    int64     `json:"number"`
	Name      string    `json:"name"`
	Price     float64   `json:"price"`
	Comment   string    `json:"comment"`
	Uid       string    `json:"uid"`
	Qty       float64   `json:"qty"`
	Units     string    `json:"units"`
	Taxid     float64   `json:"taxid"`
	CreatedAt time.Time `json:"created_at"`
	UpdatedAt time.Time `json:"updated_at"`
}

type CreateInvoiceRowStmt struct {
	stmt *sqlite.Stmt
}

func CreateInvoiceRow(tx *sqlite.Conn) *CreateInvoiceRowStmt {
	stmt := tx.Prep(`
INSERT INTO invoice_rows (
        id,
        invoice_id,
        number,
        name,
        price,
        comment,
        uid,
        qty,
        units,
        taxid,
        created_at,
        updated_at
) VALUES (
        ?,
        ?,
        ?,
        ?,
        ?,
        ?,
        ?,
        ?,
        ?,
        ?,
        ?,
        ?
)
    `)
	return &CreateInvoiceRowStmt{stmt: stmt}
}

func (ps *CreateInvoiceRowStmt) Run(m *InvoiceRowModel) error {
	defer ps.stmt.Reset()

	// Bind parameters
	ps.stmt.BindInt64(1, m.Id)

	ps.stmt.BindInt64(2, m.InvoiceId)

	ps.stmt.BindInt64(3, m.Number)

	ps.stmt.BindText(4, m.Name)

	ps.stmt.BindFloat(5, m.Price)

	ps.stmt.BindText(6, m.Comment)

	ps.stmt.BindText(7, m.Uid)

	ps.stmt.BindFloat(8, m.Qty)

	ps.stmt.BindText(9, m.Units)

	ps.stmt.BindFloat(10, m.Taxid)

	ps.stmt.BindFloat(11, toolbelt.TimeToJulianDay(m.CreatedAt))

	ps.stmt.BindFloat(12, toolbelt.TimeToJulianDay(m.UpdatedAt))

	if _, err := ps.stmt.Step(); err != nil {
		return fmt.Errorf("failed to insert invoice_rows: %w", err)
	}

	return nil
}

func OnceCreateInvoiceRow(tx *sqlite.Conn, m *InvoiceRowModel) error {
	ps := CreateInvoiceRow(tx)
	return ps.Run(m)
}

type ReadAllInvoiceRowsStmt struct {
	stmt *sqlite.Stmt
}

func ReadAllInvoiceRows(tx *sqlite.Conn) *ReadAllInvoiceRowsStmt {
	stmt := tx.Prep(`
SELECT
        id,
        invoice_id,
        number,
        name,
        price,
        comment,
        uid,
        qty,
        units,
        taxid,
        created_at,
        updated_at
FROM invoice_rows
    `)
	return &ReadAllInvoiceRowsStmt{stmt: stmt}
}

func (ps *ReadAllInvoiceRowsStmt) Run() ([]*InvoiceRowModel, error) {
	defer ps.stmt.Reset()

	var models []*InvoiceRowModel
	for {
		hasRow, err := ps.stmt.Step()
		if err != nil {
			return nil, fmt.Errorf("failed to read invoice_rows: %w", err)
		} else if !hasRow {
			break
		}

		m := &InvoiceRowModel{}

		m.Id = ps.stmt.ColumnInt64(0)

		m.InvoiceId = ps.stmt.ColumnInt64(1)

		m.Number = ps.stmt.ColumnInt64(2)

		m.Name = ps.stmt.ColumnText(3)

		m.Price = ps.stmt.ColumnFloat(4)

		m.Comment = ps.stmt.ColumnText(5)

		m.Uid = ps.stmt.ColumnText(6)

		m.Qty = ps.stmt.ColumnFloat(7)

		m.Units = ps.stmt.ColumnText(8)

		m.Taxid = ps.stmt.ColumnFloat(9)

		m.CreatedAt = toolbelt.JulianDayToTime(ps.stmt.ColumnFloat(10))

		m.UpdatedAt = toolbelt.JulianDayToTime(ps.stmt.ColumnFloat(11))

		models = append(models, m)
	}

	return models, nil
}

func OnceReadAllInvoiceRows(tx *sqlite.Conn) ([]*InvoiceRowModel, error) {
	ps := ReadAllInvoiceRows(tx)
	return ps.Run()
}

type ReadByIDInvoiceRowStmt struct {
	stmt *sqlite.Stmt
}

func ReadByIDInvoiceRow(tx *sqlite.Conn) *ReadByIDInvoiceRowStmt {
	stmt := tx.Prep(`
SELECT
        id,
        invoice_id,
        number,
        name,
        price,
        comment,
        uid,
        qty,
        units,
        taxid,
        created_at,
        updated_at
FROM invoice_rows
WHERE id = ?
    `)
	return &ReadByIDInvoiceRowStmt{stmt: stmt}
}

func (ps *ReadByIDInvoiceRowStmt) Run(id int64) (*InvoiceRowModel, error) {
	defer ps.stmt.Reset()

	ps.stmt.BindInt64(1, id)

	if hasRow, err := ps.stmt.Step(); err != nil {
		return nil, fmt.Errorf("failed to read invoice_rows: %w", err)
	} else if !hasRow {
		return nil, nil
	}

	m := &InvoiceRowModel{}

	m.Id = ps.stmt.ColumnInt64(0)

	m.InvoiceId = ps.stmt.ColumnInt64(1)

	m.Number = ps.stmt.ColumnInt64(2)

	m.Name = ps.stmt.ColumnText(3)

	m.Price = ps.stmt.ColumnFloat(4)

	m.Comment = ps.stmt.ColumnText(5)

	m.Uid = ps.stmt.ColumnText(6)

	m.Qty = ps.stmt.ColumnFloat(7)

	m.Units = ps.stmt.ColumnText(8)

	m.Taxid = ps.stmt.ColumnFloat(9)

	m.CreatedAt = toolbelt.JulianDayToTime(ps.stmt.ColumnFloat(10))

	m.UpdatedAt = toolbelt.JulianDayToTime(ps.stmt.ColumnFloat(11))

	return m, nil
}

func OnceReadByIDInvoiceRow(tx *sqlite.Conn, id int64) (*InvoiceRowModel, error) {
	ps := ReadByIDInvoiceRow(tx)
	return ps.Run(id)
}

func CountInvoiceRows(tx *sqlite.Conn) (int64, error) {
	stmt := tx.Prep(`
SELECT COUNT(*)
FROM invoice_rows
    `)
	defer stmt.Reset()

	if hasRow, err := stmt.Step(); err != nil {
		return 0, fmt.Errorf("failed to count invoice_rows: %w", err)
	} else if !hasRow {
		return 0, nil
	}

	return stmt.ColumnInt64(0), nil
}

func OnceCountInvoiceRows(tx *sqlite.Conn) (int64, error) {
	return CountInvoiceRows(tx)
}

type UpdateInvoiceRowStmt struct {
	stmt *sqlite.Stmt
}

func UpdateInvoiceRow(tx *sqlite.Conn) *UpdateInvoiceRowStmt {
	stmt := tx.Prep(`
UPDATE invoice_rows
SET
        invoice_id = ?2,
        number = ?3,
        name = ?4,
        price = ?5,
        comment = ?6,
        uid = ?7,
        qty = ?8,
        units = ?9,
        taxid = ?10,
        created_at = ?11,
        updated_at = ?12
WHERE id = ?1
    `)
	return &UpdateInvoiceRowStmt{stmt: stmt}
}

func (ps *UpdateInvoiceRowStmt) Run(m *InvoiceRowModel) error {
	defer ps.stmt.Reset()

	// Bind parameters
	ps.stmt.BindInt64(1, m.Id)

	ps.stmt.BindInt64(2, m.InvoiceId)

	ps.stmt.BindInt64(3, m.Number)

	ps.stmt.BindText(4, m.Name)

	ps.stmt.BindFloat(5, m.Price)

	ps.stmt.BindText(6, m.Comment)

	ps.stmt.BindText(7, m.Uid)

	ps.stmt.BindFloat(8, m.Qty)

	ps.stmt.BindText(9, m.Units)

	ps.stmt.BindFloat(10, m.Taxid)

	ps.stmt.BindFloat(11, toolbelt.TimeToJulianDay(m.CreatedAt))

	ps.stmt.BindFloat(12, toolbelt.TimeToJulianDay(m.UpdatedAt))

	if _, err := ps.stmt.Step(); err != nil {
		return fmt.Errorf("failed to update invoice_rows: %w", err)
	}

	return nil
}

func OnceUpdateInvoiceRow(tx *sqlite.Conn, m *InvoiceRowModel) error {
	ps := UpdateInvoiceRow(tx)
	return ps.Run(m)
}

type DeleteInvoiceRowStmt struct {
	stmt *sqlite.Stmt
}

func DeleteInvoiceRow(tx *sqlite.Conn) *DeleteInvoiceRowStmt {
	stmt := tx.Prep(`
DELETE FROM invoice_rows
WHERE id = ?
    `)
	return &DeleteInvoiceRowStmt{stmt: stmt}
}

func (ps *DeleteInvoiceRowStmt) Run(id int64) error {
	defer ps.stmt.Reset()

	ps.stmt.BindInt64(1, id)

	if _, err := ps.stmt.Step(); err != nil {
		return fmt.Errorf("failed to delete invoice_rows: %w", err)
	}

	return nil
}

func OnceDeleteInvoiceRow(tx *sqlite.Conn, id int64) error {
	ps := DeleteInvoiceRow(tx)
	return ps.Run(id)
}
