// Code generated by "sqlc-gen-zombiezen". DO NOT EDIT.

package zz

import (
	"fmt"
	"time"

	"github.com/delaneyj/toolbelt"
	"zombiezen.com/go/sqlite"
)

type SettingModel struct {
	Id         int64     `json:"id"`
	Uuid       string    `json:"uuid"`
	Name       string    `json:"name"`
	Code       string    `json:"code"`
	Taxid      string    `json:"taxid"`
	Email      string    `json:"email"`
	Phone      string    `json:"phone"`
	Address    string    `json:"address"`
	Country    string    `json:"country"`
	SerialName string    `json:"serial_name"`
	SerialNo   int64     `json:"serial_no"`
	CreatedAt  time.Time `json:"created_at"`
	UpdatedAt  time.Time `json:"updated_at"`
}

type CreateSettingStmt struct {
	stmt *sqlite.Stmt
}

func CreateSetting(tx *sqlite.Conn) *CreateSettingStmt {
	stmt := tx.Prep(`
INSERT INTO settings (
        id,
        uuid,
        name,
        code,
        taxid,
        email,
        phone,
        address,
        country,
        serial_name,
        serial_no,
        created_at,
        updated_at
) VALUES (
        ?,
        ?,
        ?,
        ?,
        ?,
        ?,
        ?,
        ?,
        ?,
        ?,
        ?,
        ?,
        ?
)
    `)
	return &CreateSettingStmt{stmt: stmt}
}

func (ps *CreateSettingStmt) Run(m *SettingModel) error {
	defer ps.stmt.Reset()

	// Bind parameters
	ps.stmt.BindInt64(1, m.Id)

	ps.stmt.BindText(2, m.Uuid)

	ps.stmt.BindText(3, m.Name)

	ps.stmt.BindText(4, m.Code)

	ps.stmt.BindText(5, m.Taxid)

	ps.stmt.BindText(6, m.Email)

	ps.stmt.BindText(7, m.Phone)

	ps.stmt.BindText(8, m.Address)

	ps.stmt.BindText(9, m.Country)

	ps.stmt.BindText(10, m.SerialName)

	ps.stmt.BindInt64(11, m.SerialNo)

	ps.stmt.BindFloat(12, toolbelt.TimeToJulianDay(m.CreatedAt))

	ps.stmt.BindFloat(13, toolbelt.TimeToJulianDay(m.UpdatedAt))

	if _, err := ps.stmt.Step(); err != nil {
		return fmt.Errorf("failed to insert settings: %w", err)
	}

	return nil
}

func OnceCreateSetting(tx *sqlite.Conn, m *SettingModel) error {
	ps := CreateSetting(tx)
	return ps.Run(m)
}

type ReadAllSettingsStmt struct {
	stmt *sqlite.Stmt
}

func ReadAllSettings(tx *sqlite.Conn) *ReadAllSettingsStmt {
	stmt := tx.Prep(`
SELECT
        id,
        uuid,
        name,
        code,
        taxid,
        email,
        phone,
        address,
        country,
        serial_name,
        serial_no,
        created_at,
        updated_at
FROM settings
    `)
	return &ReadAllSettingsStmt{stmt: stmt}
}

func (ps *ReadAllSettingsStmt) Run() ([]*SettingModel, error) {
	defer ps.stmt.Reset()

	var models []*SettingModel
	for {
		hasRow, err := ps.stmt.Step()
		if err != nil {
			return nil, fmt.Errorf("failed to read settings: %w", err)
		} else if !hasRow {
			break
		}

		m := &SettingModel{}

		m.Id = ps.stmt.ColumnInt64(0)

		m.Uuid = ps.stmt.ColumnText(1)

		m.Name = ps.stmt.ColumnText(2)

		m.Code = ps.stmt.ColumnText(3)

		m.Taxid = ps.stmt.ColumnText(4)

		m.Email = ps.stmt.ColumnText(5)

		m.Phone = ps.stmt.ColumnText(6)

		m.Address = ps.stmt.ColumnText(7)

		m.Country = ps.stmt.ColumnText(8)

		m.SerialName = ps.stmt.ColumnText(9)

		m.SerialNo = ps.stmt.ColumnInt64(10)

		m.CreatedAt = toolbelt.JulianDayToTime(ps.stmt.ColumnFloat(11))

		m.UpdatedAt = toolbelt.JulianDayToTime(ps.stmt.ColumnFloat(12))

		models = append(models, m)
	}

	return models, nil
}

func OnceReadAllSettings(tx *sqlite.Conn) ([]*SettingModel, error) {
	ps := ReadAllSettings(tx)
	return ps.Run()
}

type ReadByIDSettingStmt struct {
	stmt *sqlite.Stmt
}

func ReadByIDSetting(tx *sqlite.Conn) *ReadByIDSettingStmt {
	stmt := tx.Prep(`
SELECT
        id,
        uuid,
        name,
        code,
        taxid,
        email,
        phone,
        address,
        country,
        serial_name,
        serial_no,
        created_at,
        updated_at
FROM settings
WHERE id = ?
    `)
	return &ReadByIDSettingStmt{stmt: stmt}
}

func (ps *ReadByIDSettingStmt) Run(id int64) (*SettingModel, error) {
	defer ps.stmt.Reset()

	ps.stmt.BindInt64(1, id)

	if hasRow, err := ps.stmt.Step(); err != nil {
		return nil, fmt.Errorf("failed to read settings: %w", err)
	} else if !hasRow {
		return nil, nil
	}

	m := &SettingModel{}

	m.Id = ps.stmt.ColumnInt64(0)

	m.Uuid = ps.stmt.ColumnText(1)

	m.Name = ps.stmt.ColumnText(2)

	m.Code = ps.stmt.ColumnText(3)

	m.Taxid = ps.stmt.ColumnText(4)

	m.Email = ps.stmt.ColumnText(5)

	m.Phone = ps.stmt.ColumnText(6)

	m.Address = ps.stmt.ColumnText(7)

	m.Country = ps.stmt.ColumnText(8)

	m.SerialName = ps.stmt.ColumnText(9)

	m.SerialNo = ps.stmt.ColumnInt64(10)

	m.CreatedAt = toolbelt.JulianDayToTime(ps.stmt.ColumnFloat(11))

	m.UpdatedAt = toolbelt.JulianDayToTime(ps.stmt.ColumnFloat(12))

	return m, nil
}

func OnceReadByIDSetting(tx *sqlite.Conn, id int64) (*SettingModel, error) {
	ps := ReadByIDSetting(tx)
	return ps.Run(id)
}

func CountSettings(tx *sqlite.Conn) (int64, error) {
	stmt := tx.Prep(`
SELECT COUNT(*)
FROM settings
    `)
	defer stmt.Reset()

	if hasRow, err := stmt.Step(); err != nil {
		return 0, fmt.Errorf("failed to count settings: %w", err)
	} else if !hasRow {
		return 0, nil
	}

	return stmt.ColumnInt64(0), nil
}

func OnceCountSettings(tx *sqlite.Conn) (int64, error) {
	return CountSettings(tx)
}

type UpdateSettingStmt struct {
	stmt *sqlite.Stmt
}

func UpdateSetting(tx *sqlite.Conn) *UpdateSettingStmt {
	stmt := tx.Prep(`
UPDATE settings
SET
        uuid = ?2,
        name = ?3,
        code = ?4,
        taxid = ?5,
        email = ?6,
        phone = ?7,
        address = ?8,
        country = ?9,
        serial_name = ?10,
        serial_no = ?11,
        created_at = ?12,
        updated_at = ?13
WHERE id = ?1
    `)
	return &UpdateSettingStmt{stmt: stmt}
}

func (ps *UpdateSettingStmt) Run(m *SettingModel) error {
	defer ps.stmt.Reset()

	// Bind parameters
	ps.stmt.BindInt64(1, m.Id)

	ps.stmt.BindText(2, m.Uuid)

	ps.stmt.BindText(3, m.Name)

	ps.stmt.BindText(4, m.Code)

	ps.stmt.BindText(5, m.Taxid)

	ps.stmt.BindText(6, m.Email)

	ps.stmt.BindText(7, m.Phone)

	ps.stmt.BindText(8, m.Address)

	ps.stmt.BindText(9, m.Country)

	ps.stmt.BindText(10, m.SerialName)

	ps.stmt.BindInt64(11, m.SerialNo)

	ps.stmt.BindFloat(12, toolbelt.TimeToJulianDay(m.CreatedAt))

	ps.stmt.BindFloat(13, toolbelt.TimeToJulianDay(m.UpdatedAt))

	if _, err := ps.stmt.Step(); err != nil {
		return fmt.Errorf("failed to update settings: %w", err)
	}

	return nil
}

func OnceUpdateSetting(tx *sqlite.Conn, m *SettingModel) error {
	ps := UpdateSetting(tx)
	return ps.Run(m)
}

type DeleteSettingStmt struct {
	stmt *sqlite.Stmt
}

func DeleteSetting(tx *sqlite.Conn) *DeleteSettingStmt {
	stmt := tx.Prep(`
DELETE FROM settings
WHERE id = ?
    `)
	return &DeleteSettingStmt{stmt: stmt}
}

func (ps *DeleteSettingStmt) Run(id int64) error {
	defer ps.stmt.Reset()

	ps.stmt.BindInt64(1, id)

	if _, err := ps.stmt.Step(); err != nil {
		return fmt.Errorf("failed to delete settings: %w", err)
	}

	return nil
}

func OnceDeleteSetting(tx *sqlite.Conn, id int64) error {
	ps := DeleteSetting(tx)
	return ps.Run(id)
}
