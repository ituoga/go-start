// Code generated by "sqlc-gen-zombiezen". DO NOT EDIT.

package zz

import (
	"fmt"

	"zombiezen.com/go/sqlite"

	"time"

	"github.com/delaneyj/toolbelt"
)

type UserByEmailRes struct {
	Id          int64     `json:"id"`
	Uuid        string    `json:"uuid"`
	Username    string    `json:"username"`
	Password    string    `json:"password"`
	CreatedAt   time.Time `json:"created_at"`
	UpdatedAt   time.Time `json:"updated_at"`
	ConfirmedAt time.Time `json:"confirmed_at"`
	DeletedAt   time.Time `json:"deleted_at"`
}

type UserByEmailStmt struct {
	stmt *sqlite.Stmt
}

func UserByEmail(tx *sqlite.Conn) *UserByEmailStmt {
	// Prepare the statement into connection cache
	stmt := tx.Prep(`
SELECT
    id, uuid, username, password, created_at, updated_at, confirmed_at, deleted_at
FROM
    users
WHERE
    username = ?1
    `)
	ps := &UserByEmailStmt{stmt: stmt}
	return ps
}

func (ps *UserByEmailStmt) Run(
	email string,
) (
	res *UserByEmailRes,
	err error,
) {
	defer ps.stmt.Reset()

	// Bind parameters
	ps.stmt.BindText(1, email)

	// Execute the query
	if hasRow, err := ps.stmt.Step(); err != nil {
		return res, fmt.Errorf("failed to execute {{.Name.Lower}} SQL: %w", err)
	} else if hasRow {
		row := UserByEmailRes{}
		row.Id = ps.stmt.ColumnInt64(0)
		row.Uuid = ps.stmt.ColumnText(1)
		row.Username = ps.stmt.ColumnText(2)
		row.Password = ps.stmt.ColumnText(3)
		row.CreatedAt = toolbelt.JulianDayToTime(ps.stmt.ColumnFloat(4))
		row.UpdatedAt = toolbelt.JulianDayToTime(ps.stmt.ColumnFloat(5))
		row.ConfirmedAt = toolbelt.JulianDayToTime(ps.stmt.ColumnFloat(6))
		row.DeletedAt = toolbelt.JulianDayToTime(ps.stmt.ColumnFloat(7))
		res = &row
	}

	return res, nil
}

func OnceUserByEmail(
	tx *sqlite.Conn,
	email string,
) (
	res *UserByEmailRes,
	err error,
) {
	ps := UserByEmail(tx)

	return ps.Run(
		email,
	)
}
