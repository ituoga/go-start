// Code generated by "sqlc-gen-zombiezen". DO NOT EDIT.

package zz

import (
	"fmt"
	"time"

	"github.com/delaneyj/toolbelt"
	"zombiezen.com/go/sqlite"
)

type InvoiceModel struct {
	Id               int64     `json:"id"`
	Uuid             string    `json:"uuid"`
	DocumentDate     time.Time `json:"document_date"`
	DueDate          time.Time `json:"due_date"`
	Currency         string    `json:"currency"`
	Rate             float64   `json:"rate"`
	SerialName       string    `json:"serial_name"`
	SerialNo         int64     `json:"serial_no"`
	RecipientName    string    `json:"recipient_name"`
	RecipientCode    string    `json:"recipient_code"`
	RecipientTaxid   string    `json:"recipient_taxid"`
	RecipientEmail   string    `json:"recipient_email"`
	RecipientPhone   string    `json:"recipient_phone"`
	RecipientAddr    string    `json:"recipient_addr"`
	RecipientCountry string    `json:"recipient_country"`
	WrittenBy        string    `json:"written_by"`
	TakenBy          string    `json:"taken_by"`
	AmountWithVat    time.Time `json:"amount_with_vat"`
	AmountVat        time.Time `json:"amount_vat"`
	AmountTotal      float64   `json:"amount_total"`
	CreatedAt        time.Time `json:"created_at"`
	UpdatedAt        time.Time `json:"updated_at"`
}

type CreateInvoiceStmt struct {
	stmt *sqlite.Stmt
}

func CreateInvoice(tx *sqlite.Conn) *CreateInvoiceStmt {
	stmt := tx.Prep(`
INSERT INTO invoices (
        id,
        uuid,
        document_date,
        due_date,
        currency,
        rate,
        serial_name,
        serial_no,
        recipient_name,
        recipient_code,
        recipient_taxid,
        recipient_email,
        recipient_phone,
        recipient_addr,
        recipient_country,
        written_by,
        taken_by,
        amount_with_vat,
        amount_vat,
        amount_total,
        created_at,
        updated_at
) VALUES (
        ?,
        ?,
        ?,
        ?,
        ?,
        ?,
        ?,
        ?,
        ?,
        ?,
        ?,
        ?,
        ?,
        ?,
        ?,
        ?,
        ?,
        ?,
        ?,
        ?,
        ?,
        ?
)
    `)
	return &CreateInvoiceStmt{stmt: stmt}
}

func (ps *CreateInvoiceStmt) Run(m *InvoiceModel) error {
	defer ps.stmt.Reset()

	// Bind parameters
	ps.stmt.BindInt64(1, m.Id)

	ps.stmt.BindText(2, m.Uuid)

	ps.stmt.BindFloat(3, toolbelt.TimeToJulianDay(m.DocumentDate))

	ps.stmt.BindFloat(4, toolbelt.TimeToJulianDay(m.DueDate))

	ps.stmt.BindText(5, m.Currency)

	ps.stmt.BindFloat(6, m.Rate)

	ps.stmt.BindText(7, m.SerialName)

	ps.stmt.BindInt64(8, m.SerialNo)

	ps.stmt.BindText(9, m.RecipientName)

	ps.stmt.BindText(10, m.RecipientCode)

	ps.stmt.BindText(11, m.RecipientTaxid)

	ps.stmt.BindText(12, m.RecipientEmail)

	ps.stmt.BindText(13, m.RecipientPhone)

	ps.stmt.BindText(14, m.RecipientAddr)

	ps.stmt.BindText(15, m.RecipientCountry)

	ps.stmt.BindText(16, m.WrittenBy)

	ps.stmt.BindText(17, m.TakenBy)

	ps.stmt.BindFloat(18, toolbelt.TimeToJulianDay(m.AmountWithVat))

	ps.stmt.BindFloat(19, toolbelt.TimeToJulianDay(m.AmountVat))

	ps.stmt.BindFloat(20, m.AmountTotal)

	ps.stmt.BindFloat(21, toolbelt.TimeToJulianDay(m.CreatedAt))

	ps.stmt.BindFloat(22, toolbelt.TimeToJulianDay(m.UpdatedAt))

	if _, err := ps.stmt.Step(); err != nil {
		return fmt.Errorf("failed to insert invoices: %w", err)
	}

	return nil
}

func OnceCreateInvoice(tx *sqlite.Conn, m *InvoiceModel) error {
	ps := CreateInvoice(tx)
	return ps.Run(m)
}

type ReadAllInvoicesStmt struct {
	stmt *sqlite.Stmt
}

func ReadAllInvoices(tx *sqlite.Conn) *ReadAllInvoicesStmt {
	stmt := tx.Prep(`
SELECT
        id,
        uuid,
        document_date,
        due_date,
        currency,
        rate,
        serial_name,
        serial_no,
        recipient_name,
        recipient_code,
        recipient_taxid,
        recipient_email,
        recipient_phone,
        recipient_addr,
        recipient_country,
        written_by,
        taken_by,
        amount_with_vat,
        amount_vat,
        amount_total,
        created_at,
        updated_at
FROM invoices
    `)
	return &ReadAllInvoicesStmt{stmt: stmt}
}

func (ps *ReadAllInvoicesStmt) Run() ([]*InvoiceModel, error) {
	defer ps.stmt.Reset()

	var models []*InvoiceModel
	for {
		hasRow, err := ps.stmt.Step()
		if err != nil {
			return nil, fmt.Errorf("failed to read invoices: %w", err)
		} else if !hasRow {
			break
		}

		m := &InvoiceModel{}

		m.Id = ps.stmt.ColumnInt64(0)

		m.Uuid = ps.stmt.ColumnText(1)

		m.DocumentDate = toolbelt.JulianDayToTime(ps.stmt.ColumnFloat(2))

		m.DueDate = toolbelt.JulianDayToTime(ps.stmt.ColumnFloat(3))

		m.Currency = ps.stmt.ColumnText(4)

		m.Rate = ps.stmt.ColumnFloat(5)

		m.SerialName = ps.stmt.ColumnText(6)

		m.SerialNo = ps.stmt.ColumnInt64(7)

		m.RecipientName = ps.stmt.ColumnText(8)

		m.RecipientCode = ps.stmt.ColumnText(9)

		m.RecipientTaxid = ps.stmt.ColumnText(10)

		m.RecipientEmail = ps.stmt.ColumnText(11)

		m.RecipientPhone = ps.stmt.ColumnText(12)

		m.RecipientAddr = ps.stmt.ColumnText(13)

		m.RecipientCountry = ps.stmt.ColumnText(14)

		m.WrittenBy = ps.stmt.ColumnText(15)

		m.TakenBy = ps.stmt.ColumnText(16)

		m.AmountWithVat = toolbelt.JulianDayToTime(ps.stmt.ColumnFloat(17))

		m.AmountVat = toolbelt.JulianDayToTime(ps.stmt.ColumnFloat(18))

		m.AmountTotal = ps.stmt.ColumnFloat(19)

		m.CreatedAt = toolbelt.JulianDayToTime(ps.stmt.ColumnFloat(20))

		m.UpdatedAt = toolbelt.JulianDayToTime(ps.stmt.ColumnFloat(21))

		models = append(models, m)
	}

	return models, nil
}

func OnceReadAllInvoices(tx *sqlite.Conn) ([]*InvoiceModel, error) {
	ps := ReadAllInvoices(tx)
	return ps.Run()
}

type ReadByIDInvoiceStmt struct {
	stmt *sqlite.Stmt
}

func ReadByIDInvoice(tx *sqlite.Conn) *ReadByIDInvoiceStmt {
	stmt := tx.Prep(`
SELECT
        id,
        uuid,
        document_date,
        due_date,
        currency,
        rate,
        serial_name,
        serial_no,
        recipient_name,
        recipient_code,
        recipient_taxid,
        recipient_email,
        recipient_phone,
        recipient_addr,
        recipient_country,
        written_by,
        taken_by,
        amount_with_vat,
        amount_vat,
        amount_total,
        created_at,
        updated_at
FROM invoices
WHERE id = ?
    `)
	return &ReadByIDInvoiceStmt{stmt: stmt}
}

func (ps *ReadByIDInvoiceStmt) Run(id int64) (*InvoiceModel, error) {
	defer ps.stmt.Reset()

	ps.stmt.BindInt64(1, id)

	if hasRow, err := ps.stmt.Step(); err != nil {
		return nil, fmt.Errorf("failed to read invoices: %w", err)
	} else if !hasRow {
		return nil, nil
	}

	m := &InvoiceModel{}

	m.Id = ps.stmt.ColumnInt64(0)

	m.Uuid = ps.stmt.ColumnText(1)

	m.DocumentDate = toolbelt.JulianDayToTime(ps.stmt.ColumnFloat(2))

	m.DueDate = toolbelt.JulianDayToTime(ps.stmt.ColumnFloat(3))

	m.Currency = ps.stmt.ColumnText(4)

	m.Rate = ps.stmt.ColumnFloat(5)

	m.SerialName = ps.stmt.ColumnText(6)

	m.SerialNo = ps.stmt.ColumnInt64(7)

	m.RecipientName = ps.stmt.ColumnText(8)

	m.RecipientCode = ps.stmt.ColumnText(9)

	m.RecipientTaxid = ps.stmt.ColumnText(10)

	m.RecipientEmail = ps.stmt.ColumnText(11)

	m.RecipientPhone = ps.stmt.ColumnText(12)

	m.RecipientAddr = ps.stmt.ColumnText(13)

	m.RecipientCountry = ps.stmt.ColumnText(14)

	m.WrittenBy = ps.stmt.ColumnText(15)

	m.TakenBy = ps.stmt.ColumnText(16)

	m.AmountWithVat = toolbelt.JulianDayToTime(ps.stmt.ColumnFloat(17))

	m.AmountVat = toolbelt.JulianDayToTime(ps.stmt.ColumnFloat(18))

	m.AmountTotal = ps.stmt.ColumnFloat(19)

	m.CreatedAt = toolbelt.JulianDayToTime(ps.stmt.ColumnFloat(20))

	m.UpdatedAt = toolbelt.JulianDayToTime(ps.stmt.ColumnFloat(21))

	return m, nil
}

func OnceReadByIDInvoice(tx *sqlite.Conn, id int64) (*InvoiceModel, error) {
	ps := ReadByIDInvoice(tx)
	return ps.Run(id)
}

func CountInvoices(tx *sqlite.Conn) (int64, error) {
	stmt := tx.Prep(`
SELECT COUNT(*)
FROM invoices
    `)
	defer stmt.Reset()

	if hasRow, err := stmt.Step(); err != nil {
		return 0, fmt.Errorf("failed to count invoices: %w", err)
	} else if !hasRow {
		return 0, nil
	}

	return stmt.ColumnInt64(0), nil
}

func OnceCountInvoices(tx *sqlite.Conn) (int64, error) {
	return CountInvoices(tx)
}

type UpdateInvoiceStmt struct {
	stmt *sqlite.Stmt
}

func UpdateInvoice(tx *sqlite.Conn) *UpdateInvoiceStmt {
	stmt := tx.Prep(`
UPDATE invoices
SET
        uuid = ?2,
        document_date = ?3,
        due_date = ?4,
        currency = ?5,
        rate = ?6,
        serial_name = ?7,
        serial_no = ?8,
        recipient_name = ?9,
        recipient_code = ?10,
        recipient_taxid = ?11,
        recipient_email = ?12,
        recipient_phone = ?13,
        recipient_addr = ?14,
        recipient_country = ?15,
        written_by = ?16,
        taken_by = ?17,
        amount_with_vat = ?18,
        amount_vat = ?19,
        amount_total = ?20,
        created_at = ?21,
        updated_at = ?22
WHERE id = ?1
    `)
	return &UpdateInvoiceStmt{stmt: stmt}
}

func (ps *UpdateInvoiceStmt) Run(m *InvoiceModel) error {
	defer ps.stmt.Reset()

	// Bind parameters
	ps.stmt.BindInt64(1, m.Id)

	ps.stmt.BindText(2, m.Uuid)

	ps.stmt.BindFloat(3, toolbelt.TimeToJulianDay(m.DocumentDate))

	ps.stmt.BindFloat(4, toolbelt.TimeToJulianDay(m.DueDate))

	ps.stmt.BindText(5, m.Currency)

	ps.stmt.BindFloat(6, m.Rate)

	ps.stmt.BindText(7, m.SerialName)

	ps.stmt.BindInt64(8, m.SerialNo)

	ps.stmt.BindText(9, m.RecipientName)

	ps.stmt.BindText(10, m.RecipientCode)

	ps.stmt.BindText(11, m.RecipientTaxid)

	ps.stmt.BindText(12, m.RecipientEmail)

	ps.stmt.BindText(13, m.RecipientPhone)

	ps.stmt.BindText(14, m.RecipientAddr)

	ps.stmt.BindText(15, m.RecipientCountry)

	ps.stmt.BindText(16, m.WrittenBy)

	ps.stmt.BindText(17, m.TakenBy)

	ps.stmt.BindFloat(18, toolbelt.TimeToJulianDay(m.AmountWithVat))

	ps.stmt.BindFloat(19, toolbelt.TimeToJulianDay(m.AmountVat))

	ps.stmt.BindFloat(20, m.AmountTotal)

	ps.stmt.BindFloat(21, toolbelt.TimeToJulianDay(m.CreatedAt))

	ps.stmt.BindFloat(22, toolbelt.TimeToJulianDay(m.UpdatedAt))

	if _, err := ps.stmt.Step(); err != nil {
		return fmt.Errorf("failed to update invoices: %w", err)
	}

	return nil
}

func OnceUpdateInvoice(tx *sqlite.Conn, m *InvoiceModel) error {
	ps := UpdateInvoice(tx)
	return ps.Run(m)
}

type DeleteInvoiceStmt struct {
	stmt *sqlite.Stmt
}

func DeleteInvoice(tx *sqlite.Conn) *DeleteInvoiceStmt {
	stmt := tx.Prep(`
DELETE FROM invoices
WHERE id = ?
    `)
	return &DeleteInvoiceStmt{stmt: stmt}
}

func (ps *DeleteInvoiceStmt) Run(id int64) error {
	defer ps.stmt.Reset()

	ps.stmt.BindInt64(1, id)

	if _, err := ps.stmt.Step(); err != nil {
		return fmt.Errorf("failed to delete invoices: %w", err)
	}

	return nil
}

func OnceDeleteInvoice(tx *sqlite.Conn, id int64) error {
	ps := DeleteInvoice(tx)
	return ps.Run(id)
}
